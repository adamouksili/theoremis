// ─────────────────────────────────────────────────────────────
// Theoremis  ·  Coq Backend Emitter
// IR → Coq Gallina source code
// ─────────────────────────────────────────────────────────────

import type { Term, Tactic, Declaration, IRModule, Param } from '../core/ir';
import type { EmitterResult } from './lean4';

// ── Main emitter entry ──────────────────────────────────────

export function emitCoq(module: IRModule): EmitterResult {
    const lines: string[] = [];
    const warnings: string[] = [];

    lines.push(`(* Generated by Theoremis *)`);
    lines.push(`(* Axiom Bundle: ${module.axiomBundle.name} *)`);
    lines.push(`(* Source: ${module.name} *)`);
    lines.push('');

    // Imports
    lines.push('Require Import Arith.');
    lines.push('Require Import ZArith.');
    lines.push('Require Import Lia.');
    if (module.axiomBundle.axioms.has('LEM') || module.axiomBundle.axioms.has('Choice')) {
        lines.push('Require Import Classical.');
    }
    lines.push('');
    lines.push('Open Scope nat_scope.');
    lines.push('');

    for (const decl of module.declarations) {
        lines.push(emitDeclaration(decl));
        lines.push('');
    }

    return {
        code: lines.join('\n'),
        language: 'coq',
        fileExtension: '.v',
        warnings,
        valid: true,
    };
}

// ── Emit declaration ────────────────────────────────────────

function emitDeclaration(decl: Declaration): string {
    switch (decl.tag) {
        case 'Definition': {
            const params = decl.params.map(emitParam).join(' ');
            const retType = emitTerm(decl.returnType);
            const body = emitTerm(decl.body);
            return `Definition ${decl.name} ${params} : ${retType} :=\n  ${body}.`;
        }

        case 'Theorem': {
            const params = decl.params.map(emitParam).join(' ');
            const stmt = emitTerm(decl.statement);
            const proof = decl.proof.length > 0
                ? decl.proof.map(t => emitTactic(t, 1)).join('\n')
                : '  admit';
            const hasAdmit = proof.includes('admit');
            const closing = hasAdmit ? 'Admitted.' : 'Qed.';
            return `Theorem ${decl.name} : ${params.length > 0 ? `forall ${params},\n    ` : ''}${stmt}.\nProof.\n${proof}\n${closing}`;
        }

        case 'Lemma': {
            const params = decl.params.map(emitParam).join(' ');
            const stmt = emitTerm(decl.statement);
            const proof = decl.proof.length > 0
                ? decl.proof.map(t => emitTactic(t, 1)).join('\n')
                : '  admit';
            const hasAdmit = proof.includes('admit');
            const closing = hasAdmit ? 'Admitted.' : 'Qed.';
            return `Lemma ${decl.name} : ${params.length > 0 ? `forall ${params},\n    ` : ''}${stmt}.\nProof.\n${proof}\n${closing}`;
        }
    }
}

// ── Emit terms ──────────────────────────────────────────────

function emitTerm(term: Term): string {
    switch (term.tag) {
        case 'Var': return mapVar(term.name);
        case 'Literal':
            if (term.kind === 'Bool') return term.value === 'true' ? 'true' : 'false';
            return term.value;

        case 'Lam':
            return `fun (${term.param} : ${emitTerm(term.paramType)}) => ${emitTerm(term.body)}`;

        case 'App':
            return `(${emitTerm(term.func)} ${emitTerm(term.arg)})`;

        case 'Pi':
            if (term.param === '_') {
                return `${emitTerm(term.paramType)} -> ${emitTerm(term.body)}`;
            }
            return `forall (${term.param} : ${emitTerm(term.paramType)}), ${emitTerm(term.body)}`;

        case 'Sigma':
            return `{ ${term.param} : ${emitTerm(term.paramType)} & ${emitTerm(term.body)} }`;

        case 'Pair':
            return `existT _ (${emitTerm(term.fst)}) (${emitTerm(term.snd)})`;

        case 'Proj':
            return term.index === 1 ? `projT1 (${emitTerm(term.term)})` : `projT2 (${emitTerm(term.term)})`;

        case 'LetIn':
            return `let ${term.name} : ${emitTerm(term.type)} := ${emitTerm(term.value)} in\n  ${emitTerm(term.body)}`;

        case 'Sort':
            return term.universe.tag === 'Prop' ? 'Prop' : `Type`;

        case 'Ind': {
            const ctors = term.constructors.map(c => `  | ${c.name} : ${emitTerm(c.type)}`).join('\n');
            return `Inductive ${term.name} : ${emitTerm(term.type)} :=\n${ctors}.`;
        }

        case 'Match':
            return `match ${emitTerm(term.scrutinee)} with\n` +
                term.cases.map(c => `  | ${c.pattern}${c.bindings.length ? ' ' + c.bindings.join(' ') : ''} => ${emitTerm(c.body)}`).join('\n') +
                '\n  end';

        case 'Hole':
            return '_';

        case 'AxiomRef':
            return mapAxiomCoq(term.axiom);

        case 'BinOp': {
            const l = emitTerm(term.left);
            const r = emitTerm(term.right);
            return `(${l} ${mapOpCoq(term.op)} ${r})`;
        }

        case 'UnaryOp':
            if (term.op === '¬') return `~(${emitTerm(term.operand)})`;
            return `(-(${emitTerm(term.operand)}))`;

        case 'Equiv':
            if (term.modulus) {
                return `(${emitTerm(term.left)} mod ${emitTerm(term.modulus)} = ${emitTerm(term.right)} mod ${emitTerm(term.modulus)})`;
            }
            return `(${emitTerm(term.left)} = ${emitTerm(term.right)})`;

        case 'ForAll':
            return `forall (${term.param} : ${emitTerm(term.domain)}), ${emitTerm(term.body)}`;

        case 'Exists':
            return `exists (${term.param} : ${emitTerm(term.domain)}), ${emitTerm(term.body)}`;
    }
}

// ── Emit tactics ────────────────────────────────────────────

function emitTactic(tactic: Tactic, indent: number): string {
    const pad = '  '.repeat(indent);
    switch (tactic.tag) {
        case 'Intro': return `${pad}intros ${tactic.names.join(' ')}.`;
        case 'Apply': return `${pad}apply ${emitTerm(tactic.term)}.`;
        case 'Rewrite': return `${pad}rewrite ${tactic.direction === 'rtl' ? '<- ' : ''}${emitTerm(tactic.term)}.`;
        case 'Induction': return `${pad}induction ${tactic.name}.`;
        case 'Cases': return `${pad}destruct ${emitTerm(tactic.term)}.`;
        case 'Simp': return `${pad}simpl${tactic.lemmas.length > 0 ? '; auto' : ''}.`;
        case 'Omega': return `${pad}lia.`;
        case 'Sorry': return `${pad}admit.`;
        case 'Auto': return `${pad}auto ${tactic.depth}.`;
        case 'Seq': return tactic.tactics.map(t => emitTactic(t, indent)).join('\n');
        case 'Alt': return `${pad}try (${tactic.tactics.map(t => emitTactic(t, 0).trim()).join('; ')}).`;
        case 'Exact': return `${pad}exact ${emitTerm(tactic.term)}.`;
        case 'Ring': return `${pad}ring.`;
        case 'LLMSuggest': return `${pad}(* AI suggestion: ${tactic.context} *)\n${pad}admit.`;
    }
}

function emitParam(param: Param): string {
    return `(${param.name} : ${emitTerm(param.type)})`;
}

// ── Coq mappings ────────────────────────────────────────────

function mapVar(name: string): string {
    const map: Record<string, string> = {
        'ℕ': 'nat', 'ℤ': 'Z', 'ℝ': 'R', 'ℂ': 'C',
        'Bool': 'bool', 'Prime': 'prime', 'Even': 'Nat.even',
        'Divisors': 'Nat.divisors',
    };
    return map[name] ?? name;
}

function mapOpCoq(op: string): string {
    const map: Record<string, string> = {
        '+': '+', '-': '-', '*': '*', '/': '/', '^': '^',
        '=': '=', '<': '<', '>': '>', '≤': '<=', '≥': '>=',
        '∧': '/\\', '∨': '\\/', '→': '->', '↔': '<->',
        'mod': 'mod', '∈': '∈',
    };
    return map[op] ?? op;
}

function mapAxiomCoq(axiom: string): string {
    const map: Record<string, string> = {
        'LEM': 'classic',
        'Choice': 'constructive_indefinite_description',
        'Funext': 'functional_extensionality',
        'Propext': 'propositional_extensionality',
        'ClassicalLogic': 'NNPP',
    };
    return map[axiom] ?? `axiom_${axiom}`;
}
