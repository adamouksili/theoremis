// ─────────────────────────────────────────────────────────────
// Theoremis  ·  Isabelle/HOL Backend Emitter
// IR → Isabelle/HOL source (with dependent type erasure)
// ─────────────────────────────────────────────────────────────

import type { Term, Tactic, Declaration, IRModule, Param } from '../core/ir';
import type { EmitterResult } from './lean4';

// ── Main emitter entry ──────────────────────────────────────

export function emitIsabelle(module: IRModule): EmitterResult {
    const lines: string[] = [];
    const warnings: string[] = [];

    lines.push(`(* Generated by Theoremis *)`);
    lines.push(`(* Axiom Bundle: ${module.axiomBundle.name} *)`);
    lines.push(`(* Source: ${module.name} *)`);
    lines.push(`(* WARNING: Dependent types are erased in Isabelle/HOL *)`);
    lines.push('');
    lines.push(`theory ${sanitizeTheoryName(module.name)}`);
    lines.push(`  imports Main HOL.HOL`);
    lines.push(`begin`);
    lines.push('');

    warnings.push('Isabelle/HOL uses simple type theory. Dependent types have been erased to predicate-guarded terms.');

    for (const decl of module.declarations) {
        const { code, warns } = emitDeclaration(decl);
        lines.push(code);
        lines.push('');
        warnings.push(...warns);
    }

    lines.push('end');

    return {
        code: lines.join('\n'),
        language: 'isabelle',
        fileExtension: '.thy',
        warnings,
        valid: true,
    };
}

// ── Emit declaration ────────────────────────────────────────

function emitDeclaration(decl: Declaration): { code: string; warns: string[] } {
    const warns: string[] = [];

    switch (decl.tag) {
        case 'Definition': {
            const params = decl.params.map(emitParam).join(' ');
            const body = emitTerm(decl.body);
            const retType = emitTerm(decl.returnType);
            const safeBody = isIsabelleGarbageBody(body) ? 'undefined' : body;
            return {
                code: `definition ${decl.name} :: "${params.length > 0 ? params + ' \\<Rightarrow> ' : ''}${retType}" where\n  "${decl.name}${params.length > 0 ? ' ' + decl.params.map(p => p.name).join(' ') : ''} = ${safeBody}"`,
                warns,
            };
        }

        case 'Theorem':
        case 'Lemma': {
            const keyword = decl.tag === 'Theorem' ? 'theorem' : 'lemma';
            const { stmt, assumptions } = emitStatementWithAssumptions(decl.params, decl.statement);
            const proof = decl.proof.length > 0
                ? decl.proof.map(t => emitTactic(t, 1)).join('\n')
                : '  sorry';

            let fullStmt = '';
            if (assumptions.length > 0) {
                const assumes = assumptions.map((a, i) => `  assumes h${i}: "${a}"`).join('\n');
                fullStmt = `${keyword} ${decl.name}:\n${assumes}\n  shows "${stmt}"`;
            } else {
                fullStmt = `${keyword} ${decl.name}: "${stmt}"`;
            }

            // Check for dependent types that needed erasure
            if (hasDependentTypes(decl.statement)) {
                warns.push(`${decl.name}: Σ-type erasure applied — some type information is lost`);
            }

            return {
                code: `${fullStmt}\n${proof}\n  done`,
                warns,
            };
        }
    }
}

// ── Emit terms (with type erasure) ──────────────────────────

function emitTerm(term: Term): string {
    switch (term.tag) {
        case 'Var': return mapVar(term.name);
        case 'Literal': return term.value;

        case 'Lam':
            return `(\\<lambda>${term.param}. ${emitTerm(term.body)})`;

        case 'App':
            return `(${emitTerm(term.func)} ${emitTerm(term.arg)})`;

        case 'Pi':
            if (term.param === '_') {
                return `${emitTerm(term.paramType)} \\<Rightarrow> ${emitTerm(term.body)}`;
            }
            // Erase dependent product to universal quantifier
            return `\\<forall>${term.param}. ${emitTerm(term.body)}`;

        case 'Sigma':
            // Erase dependent sum to existential
            return `\\<exists>${term.param}. ${emitTerm(term.body)}`;

        case 'Pair':
            return `(${emitTerm(term.fst)}, ${emitTerm(term.snd)})`;

        case 'Proj':
            return term.index === 1 ? `fst (${emitTerm(term.term)})` : `snd (${emitTerm(term.term)})`;

        case 'LetIn':
            return `let ${term.name} = ${emitTerm(term.value)} in ${emitTerm(term.body)}`;

        case 'Sort':
            return term.universe.tag === 'Prop' ? 'bool' : "'a";

        case 'Ind':
            return `datatype ${term.name} =\n` +
                term.constructors.map((c, i) => `  ${i > 0 ? '| ' : '  '}${c.name}`).join('\n');

        case 'Match':
            return `(case ${emitTerm(term.scrutinee)} of\n` +
                term.cases.map(c => `    ${c.pattern} \\<Rightarrow> ${emitTerm(c.body)}`).join(' |\n') + ')';

        case 'Hole':
            return 'undefined';

        case 'AxiomRef':
            return mapAxiomIsabelle(term.axiom);

        case 'BinOp': {
            const l = emitTerm(term.left);
            const r = emitTerm(term.right);
            return `(${l} ${mapOpIsabelle(term.op)} ${r})`;
        }

        case 'UnaryOp':
            if (term.op === '¬') return `\\<not>(${emitTerm(term.operand)})`;
            return `(- ${emitTerm(term.operand)})`;

        case 'Equiv':
            if (term.modulus) {
                return `[${emitTerm(term.left)} = ${emitTerm(term.right)}] (mod ${emitTerm(term.modulus)})`;
            }
            return `(${emitTerm(term.left)} = ${emitTerm(term.right)})`;

        case 'ForAll':
            return `\\<forall>${term.param} \\<in> ${emitTerm(term.domain)}. ${emitTerm(term.body)}`;

        case 'Exists':
            return `\\<exists>${term.param} \\<in> ${emitTerm(term.domain)}. ${emitTerm(term.body)}`;
    }
}

// ── Emit tactics ────────────────────────────────────────────

function emitTactic(tactic: Tactic, indent: number): string {
    const pad = '  '.repeat(indent);
    switch (tactic.tag) {
        case 'Intro': return `${pad}fix ${tactic.names.join(' ')}`;
        case 'Apply': return `${pad}using ${emitTerm(tactic.term)}`;
        case 'Rewrite': return `${pad}using ${emitTerm(tactic.term)} by simp`;
        case 'Induction': return `${pad}proof (induct ${tactic.name})\n${pad}  case 0 thus ?case by simp\n${pad}next\n${pad}  case (Suc ${tactic.name}) thus ?case by simp\n${pad}qed`;
        case 'Cases': return `${pad}proof (cases ${emitTerm(tactic.term)})`;
        case 'Simp': return `${pad}by simp${tactic.lemmas.length > 0 ? ' add: ' + tactic.lemmas.join(' ') : ''}`;
        case 'Omega': return `${pad}by arith`;
        case 'Sorry': return `${pad}sorry`;
        case 'Auto': return `${pad}by auto`;
        case 'Seq': return tactic.tactics.map(t => emitTactic(t, indent)).join('\n');
        case 'Alt': return `${pad}by (${tactic.tactics.map(t => emitTactic(t, 0).trim()).join(' | ')})`;
        case 'Exact': return `${pad}by (rule ${emitTerm(tactic.term)})`;
        case 'Ring': return `${pad}by algebra`;
        case 'LLMSuggest': return `${pad}(* AI suggestion: ${tactic.context} *)\n${pad}sorry`;
    }
}

function emitParam(param: Param): string {
    return `(${param.name} :: ${emitTerm(param.type)})`;
}

// ── Statement extraction with assumption splitting ──────────

function emitStatementWithAssumptions(params: Param[], statement: Term): { stmt: string; assumptions: string[] } {
    const assumptions: string[] = [];

    for (const param of params) {
        assumptions.push(`${param.name} :: ${emitTerm(param.type)}`);
    }

    return {
        stmt: emitTerm(statement),
        assumptions,
    };
}

// ── Dependent type detection ────────────────────────────────

function hasDependentTypes(term: Term): boolean {
    switch (term.tag) {
        case 'Sigma': return true;
        case 'Pi':
            if (term.param !== '_') return true;
            return hasDependentTypes(term.paramType) || hasDependentTypes(term.body);
        case 'App':
            return hasDependentTypes(term.func) || hasDependentTypes(term.arg);
        case 'BinOp':
            return hasDependentTypes(term.left) || hasDependentTypes(term.right);
        case 'ForAll':
        case 'Exists':
            return hasDependentTypes(term.domain) || hasDependentTypes(term.body);
        default: return false;
    }
}

// ── Isabelle mappings ───────────────────────────────────────

function mapVar(name: string): string {
    const map: Record<string, string> = {
        'ℕ': 'nat', 'ℤ': 'int', 'ℝ': 'real', 'ℂ': 'complex',
        'Bool': 'bool', 'Prime': 'prime', 'Even': 'even',
        'Divisors': 'divisors',
    };
    return map[name] ?? name;
}

function mapOpIsabelle(op: string): string {
    const map: Record<string, string> = {
        '+': '+', '-': '-', '*': '*', '/': 'div', '^': '^',
        '=': '=', '<': '<', '>': '>', '≤': '\\<le>', '≥': '\\<ge>',
        '∧': '\\<and>', '∨': '\\<or>', '→': '\\<longrightarrow>', '↔': '\\<longleftrightarrow>',
        'mod': 'mod', '∈': '\\<in>', '∉': '\\<notin>', '⊆': '\\<subseteq>',
        '∪': '\\<union>', '∩': '\\<inter>',
    };
    return map[op] ?? op;
}

function mapAxiomIsabelle(axiom: string): string {
    const map: Record<string, string> = {
        'LEM': 'excluded_middle',
        'Choice': 'someI',
        'Funext': 'ext',
        'ClassicalLogic': 'ccontr',
    };
    return map[axiom] ?? axiom;
}

function sanitizeTheoryName(name: string): string {
    return name.replace(/[^a-zA-Z0-9_]/g, '_').replace(/^_+|_+$/g, '') || 'Generated';
}

// ── Garbage body detection ──────────────────────────────────

const GARBAGE_WORDS = new Set([
    'a', 'an', 'the', 'is', 'are', 'was', 'were', 'be', 'let', 'for', 'all',
    'if', 'then', 'we', 'it', 'that', 'this', 'there', 'here', 'to', 'of',
    'in', 'on', 'by', 'with', 'from', 'not', 'or', 'and', 'but', 'so', 'as',
    'set', 'such', 'given', 'where', 'when', 'which', 'while', 'since',
    'thus', 'hence', 'therefore', 'prove', 'show', 'assume', 'suppose',
]);

function isIsabelleGarbageBody(body: string): boolean {
    const trimmed = body.trim();
    if (!trimmed || trimmed === 'undefined') return true;
    if (/^[A-Z]$/.test(trimmed)) return true;
    // Don't catch legitimate Isabelle syntax
    const firstWord = trimmed.split(/\s/)[0].toLowerCase();
    const ISA_KEYWORDS = new Set(['datatype', 'case', 'let', 'if', 'fun', 'primrec', 'record', 'inductive']);
    if (ISA_KEYWORDS.has(firstWord)) return false;
    if (GARBAGE_WORDS.has(trimmed.toLowerCase())) return true;
    if (/^[A-Za-z]+\s+[A-Za-z]+/.test(trimmed) && !trimmed.includes('::') && !trimmed.includes('=>')) return true;
    return false;
}
