// ─────────────────────────────────────────────────────────────
// Theoremis  ·  Lean 4 Backend Emitter
// IR → Lean 4 source code
// ─────────────────────────────────────────────────────────────

import type { Term, Tactic, Declaration, IRModule, Param, AxiomBundle } from '../core/ir';

// ── Main emitter entry ──────────────────────────────────────

export function emitLean4(module: IRModule): EmitterResult {
    const lines: string[] = [];
    const warnings: string[] = [];

    // Header
    lines.push(`-- Generated by Theoremis`);
    lines.push(`-- Axiom Bundle: ${module.axiomBundle.name}`);
    lines.push(`-- Source: ${module.name}`);
    lines.push('');

    // Imports
    lines.push('import Mathlib.Tactic');
    if (module.axiomBundle.axioms.has('Choice') || module.axiomBundle.axioms.has('LEM')) {
        lines.push('import Mathlib.Tactic.NormNum');
        lines.push('import Mathlib.Data.Nat.Prime.Basic');
    }
    // Import number theory modules if declarations reference primes/modular arithmetic
    const allCode = module.declarations.map(d => JSON.stringify(d)).join(' ');
    if (allCode.includes('Prime') || allCode.includes('Coprime')) {
        lines.push('import Mathlib.Data.Nat.Prime.Defs');
    }
    if (allCode.includes('Equiv') || allCode.includes('ModEq') || allCode.includes('ZMod')) {
        lines.push('import Mathlib.Data.ZMod.Basic');
    }
    lines.push('');
    lines.push(`open Nat`);
    lines.push('');

    // Declarations
    for (const decl of module.declarations) {
        const { code, warns } = emitDeclaration(decl, module.axiomBundle);
        lines.push(code);
        lines.push('');
        warnings.push(...warns);
    }

    return {
        code: lines.join('\n'),
        language: 'lean4',
        fileExtension: '.lean',
        warnings,
        valid: true,
    };
}

// ── Emit a declaration ──────────────────────────────────────

function emitDeclaration(decl: Declaration, bundle: AxiomBundle): { code: string; warns: string[] } {
    const warns: string[] = [];

    switch (decl.tag) {
        case 'Definition': {
            const params = decl.params.map(p => emitParam(p)).join(' ');
            const retType = emitTerm(decl.returnType);
            const body = emitTerm(decl.body);
            const paramStr = params ? `${params} ` : '';
            // If the body is just a hole, empty, or a garbage extraction from English
            // prose (e.g., parser extracted "A" from "A natural number..."), use sorry
            const safeBody = isGarbageBody(body) ? 'sorry' : body;
            return {
                code: `def ${decl.name} ${paramStr}: ${retType} :=\n  ${safeBody}`,
                warns,
            };
        }

        case 'Theorem': {
            const params = decl.params.map(p => emitParam(p)).join(' ');
            const stmt = emitTerm(decl.statement);
            const paramStr = params ? `${params} ` : '';
            const proof = decl.proof.length > 0
                ? decl.proof.map(t => emitTactic(t, 1)).join('\n')
                : '  sorry';

            // Check axiom compatibility
            if (decl.axiomBundle) {
                for (const axiom of decl.axiomBundle.axioms) {
                    if (!bundle.axioms.has(axiom)) {
                        warns.push(`Theorem '${decl.name}' uses axiom '${axiom}' not in target bundle`);
                    }
                }
            }

            return {
                code: `theorem ${decl.name} ${paramStr}:\n    ${stmt} := by\n${proof}`,
                warns,
            };
        }

        case 'Lemma': {
            const params = decl.params.map(p => emitParam(p)).join(' ');
            const stmt = emitTerm(decl.statement);
            const paramStr = params ? `${params} ` : '';
            const proof = decl.proof.length > 0
                ? decl.proof.map(t => emitTactic(t, 1)).join('\n')
                : '  sorry';
            return {
                code: `lemma ${decl.name} ${paramStr}:\n    ${stmt} := by\n${proof}`,
                warns,
            };
        }
    }
}

// ── Emit terms ──────────────────────────────────────────────

function emitTerm(term: Term): string {
    switch (term.tag) {
        case 'Var': return mapVar(term.name);
        case 'Literal':
            if (term.kind === 'Bool') return term.value === 'true' ? 'True' : 'False';
            return term.value;

        case 'Lam':
            return `fun (${term.param} : ${emitTerm(term.paramType)}) => ${emitTerm(term.body)}`;

        case 'App':
            return `(${emitTerm(term.func)} ${emitTerm(term.arg)})`;

        case 'Pi':
            if (term.param === '_') {
                return `${emitTerm(term.paramType)} → ${emitTerm(term.body)}`;
            }
            return `(${term.param} : ${emitTerm(term.paramType)}) → ${emitTerm(term.body)}`;

        case 'Sigma':
            return `Σ ${term.param} : ${emitTerm(term.paramType)}, ${emitTerm(term.body)}`;

        case 'Pair':
            return `⟨${emitTerm(term.fst)}, ${emitTerm(term.snd)}⟩`;

        case 'Proj':
            return `(${emitTerm(term.term)}).${term.index}`;

        case 'LetIn':
            return `let ${term.name} : ${emitTerm(term.type)} := ${emitTerm(term.value)}\n  ${emitTerm(term.body)}`;

        case 'Sort':
            if (term.universe.tag === 'Prop') return 'Prop';
            return term.universe.level === 0 ? 'Type' : `Type ${term.universe.level}`;

        case 'Ind':
            return `inductive ${term.name} : ${emitTerm(term.type)} where\n` +
                term.constructors.map(c => `  | ${c.name} : ${emitTerm(c.type)}`).join('\n');

        case 'Match':
            return `match ${emitTerm(term.scrutinee)} with\n` +
                term.cases.map(c => `  | ${c.pattern}${c.bindings.length ? ' ' + c.bindings.join(' ') : ''} => ${emitTerm(c.body)}`).join('\n');

        case 'Hole':
            return 'sorry';

        case 'AxiomRef':
            return mapAxiomLean4(term.axiom);

        case 'BinOp': {
            const l = emitTerm(term.left);
            const r = emitTerm(term.right);
            const op = mapOpLean4(term.op);
            return `(${l} ${op} ${r})`;
        }

        case 'UnaryOp':
            if (term.op === '¬') return `¬${emitTerm(term.operand)}`;
            return `(-${emitTerm(term.operand)})`;

        case 'Equiv':
            if (term.modulus) {
                return `Int.ModEq ${emitTerm(term.modulus)} ${emitTerm(term.left)} ${emitTerm(term.right)}`;
            }
            return `${emitTerm(term.left)} = ${emitTerm(term.right)}`;

        case 'ForAll':
            return `∀ ${term.param} : ${emitTerm(term.domain)}, ${emitTerm(term.body)}`;

        case 'Exists':
            return `∃ ${term.param} : ${emitTerm(term.domain)}, ${emitTerm(term.body)}`;
    }
}

// ── Emit tactics ────────────────────────────────────────────

function emitTactic(tactic: Tactic, indent: number): string {
    const pad = '  '.repeat(indent);
    switch (tactic.tag) {
        case 'Intro': return `${pad}intro ${tactic.names.join(' ')}`;
        case 'Apply': return `${pad}apply ${emitTerm(tactic.term)}`;
        case 'Rewrite': return `${pad}rw [${tactic.direction === 'rtl' ? '← ' : ''}${emitTerm(tactic.term)}]`;
        case 'Induction': return `${pad}induction ${tactic.name} with\n${pad}| zero => sorry\n${pad}| succ n ih => sorry`;
        case 'Cases': return `${pad}cases ${emitTerm(tactic.term)}`;
        case 'Simp': return `${pad}simp${tactic.lemmas.length > 0 ? ' [' + tactic.lemmas.join(', ') + ']' : ''}`;
        case 'Omega': return `${pad}omega`;
        case 'Sorry': return `${pad}sorry`;
        case 'Auto': return `${pad}aesop`;
        case 'Seq': return tactic.tactics.map(t => emitTactic(t, indent)).join('\n');
        case 'Alt': return tactic.tactics.map(t => emitTactic(t, indent)).join(`\n${pad}<|>\n`);
        case 'Exact': return `${pad}exact ${emitTerm(tactic.term)}`;
        case 'Ring': return `${pad}ring`;
        case 'LLMSuggest': return `${pad}-- AI suggestion: ${tactic.context}\n${pad}sorry`;
    }
}

// ── Emit parameters ─────────────────────────────────────────

function emitParam(param: Param): string {
    const open = param.implicit ? '{' : '(';
    const close = param.implicit ? '}' : ')';
    return `${open}${param.name} : ${emitTerm(param.type)}${close}`;
}

// ── Lean 4 mappings ─────────────────────────────────────────

function mapVar(name: string): string {
    const map: Record<string, string> = {
        'ℕ': 'Nat', 'ℤ': 'Int', 'ℝ': 'Real', 'ℂ': 'Complex',
        'Prime': 'Nat.Prime', 'Even': 'Even', 'Odd': 'Odd',
        'Coprime': 'Nat.Coprime', 'Divisors': 'Nat.divisors',
        'Group': 'Group', 'Ring': 'Ring',
    };
    return map[name] ?? name;
}

function mapOpLean4(op: string): string {
    const map: Record<string, string> = {
        '+': '+', '-': '-', '*': '*', '/': '/', '^': '^',
        '=': '=', '<': '<', '>': '>', '≤': '≤', '≥': '≥',
        '∧': '∧', '∨': '∨', '→': '→', '↔': '↔',
        'mod': '%', '∈': '∈', '∉': '∉', '⊆': '⊆', '∪': '∪', '∩': '∩',
    };
    return map[op] ?? op;
}

function mapAxiomLean4(axiom: string): string {
    const map: Record<string, string> = {
        'LEM': 'Classical.em',
        'Choice': 'Classical.choice',
        'Funext': 'funext',
        'Propext': 'propext',
        'Quotient': 'Quotient.mk',
        'ClassicalLogic': 'Classical.byContradiction',
    };
    return map[axiom] ?? `axiom_${axiom}`;
}

// ── Garbage body detection ──────────────────────────────────
// The parser sometimes extracts English words from prose as variable names.
// E.g., "A natural number $p > 1$..." → Var('A'). Detect and replace with sorry.

const ENGLISH_WORDS = new Set([
    'a', 'an', 'the', 'is', 'are', 'was', 'were', 'be', 'been', 'being',
    'have', 'has', 'had', 'do', 'does', 'did', 'will', 'would', 'shall',
    'should', 'may', 'might', 'must', 'can', 'could', 'let', 'for', 'all',
    'if', 'then', 'we', 'it', 'its', 'that', 'this', 'there', 'here',
    'to', 'of', 'in', 'on', 'at', 'by', 'with', 'from', 'not', 'or',
    'and', 'but', 'so', 'as', 'any', 'each', 'every', 'no', 'nor',
    'say', 'says', 'said', 'set', 'such', 'given', 'where', 'when',
    'which', 'while', 'since', 'thus', 'hence', 'therefore', 'prove',
    'show', 'assume', 'suppose', 'consider', 'define', 'denote',
]);

function isGarbageBody(body: string): boolean {
    const trimmed = body.trim();
    if (!trimmed || trimmed === 'sorry') return true;
    // Single uppercase letter — almost certainly a parser artifact from English prose
    if (/^[A-Z]$/.test(trimmed)) return true;
    // Don't catch legitimate Lean 4 syntax keywords
    const firstWord = trimmed.split(/\s/)[0].toLowerCase();
    const LEAN_KEYWORDS = new Set(['match', 'fun', 'let', 'if', 'inductive', 'structure', 'class', 'instance', 'where', 'do', 'return']);
    if (LEAN_KEYWORDS.has(firstWord)) return false;
    // Common English words mistakenly extracted as variable names
    if (ENGLISH_WORDS.has(trimmed.toLowerCase())) return true;
    // Multiple words (the emitter shouldn't produce spaces in a simple term body)
    if (/^[A-Za-z]+\s+[A-Za-z]+/.test(trimmed) && !trimmed.includes(':') && !trimmed.includes('→') && !trimmed.includes('=>')) return true;
    return false;
}

// ── Emitter result type ─────────────────────────────────────

export interface EmitterResult {
    code: string;
    language: string;
    fileExtension: string;
    warnings: string[];
    valid: boolean;
}
